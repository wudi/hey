package compiler

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/wudi/php-parser/ast"
	"github.com/wudi/php-parser/compiler/opcodes"
	"github.com/wudi/php-parser/compiler/values"
)

// Compiler compiles AST to bytecode
type Compiler struct {
	instructions []opcodes.Instruction
	constants    []*values.Value
	scopes       []*Scope
	labels       map[string]int
	nextTemp     uint32
	nextLabel    int
}

// Scope represents a compilation scope (function, block, etc.)
type Scope struct {
	variables   map[string]uint32  // variable name -> slot
	parent      *Scope
	nextSlot    uint32
	isFunction  bool
	breakLabel  string
	continueLabel string
}

// NewCompiler creates a new bytecode compiler
func NewCompiler() *Compiler {
	return &Compiler{
		instructions: make([]opcodes.Instruction, 0),
		constants:    make([]*values.Value, 0),
		scopes:       make([]*Scope, 0),
		labels:       make(map[string]int),
		nextTemp:     1000, // Start temp vars at 1000 to avoid conflicts
		nextLabel:    0,
	}
}

// Compile compiles an AST node to bytecode
func (c *Compiler) Compile(node ast.Node) error {
	// Create global scope
	c.pushScope(false)
	
	err := c.compileNode(node)
	if err != nil {
		return err
	}
	
	// Add final return if needed
	if len(c.instructions) == 0 || c.instructions[len(c.instructions)-1].Opcode != opcodes.OP_RETURN {
		c.emit(opcodes.OP_RETURN, opcodes.IS_CONST, c.addConstant(values.NewNull()), 0, 0, 0, 0)
	}
	
	c.popScope()
	return nil
}

// GetBytecode returns the compiled bytecode
func (c *Compiler) GetBytecode() []opcodes.Instruction {
	return c.instructions
}

// GetConstants returns the constant pool
func (c *Compiler) GetConstants() []*values.Value {
	return c.constants
}

// Main compilation dispatcher
func (c *Compiler) compileNode(node ast.Node) error {
	if node == nil {
		return nil
	}
	
	switch n := node.(type) {
	// Expressions
	case *ast.BinaryOpExpression:
		return c.compileBinaryOp(n)
	case *ast.UnaryOpExpression:
		return c.compileUnaryOp(n)
	case *ast.AssignExpression:
		return c.compileAssign(n)
	case *ast.VariableExpression:
		return c.compileVariable(n)
	case *ast.IntegerLiteral:
		return c.compileIntegerLiteral(n)
	case *ast.FloatLiteral:
		return c.compileFloatLiteral(n)
	case *ast.StringLiteral:
		return c.compileStringLiteral(n)
	case *ast.BooleanLiteral:
		return c.compileBooleanLiteral(n)
	case *ast.NullLiteral:
		return c.compileNullLiteral(n)
	case *ast.ArrayExpression:
		return c.compileArray(n)
	case *ast.ArrayAccessExpression:
		return c.compileArrayAccess(n)
	case *ast.PropertyAccessExpression:
		return c.compilePropertyAccess(n)
	case *ast.FunctionCall:
		return c.compileFunctionCall(n)
	case *ast.MethodCall:
		return c.compileMethodCall(n)
	case *ast.TernaryExpression:
		return c.compileTernary(n)
	case *ast.CoalesceExpression:
		return c.compileCoalesce(n)
	case *ast.MatchExpression:
		return c.compileMatch(n)
		
	// Statements
	case *ast.ExpressionStatement:
		return c.compileExpressionStatement(n)
	case *ast.EchoStatement:
		return c.compileEcho(n)
	case *ast.ReturnStatement:
		return c.compileReturn(n)
	case *ast.IfStatement:
		return c.compileIf(n)
	case *ast.WhileStatement:
		return c.compileWhile(n)
	case *ast.ForStatement:
		return c.compileFor(n)
	case *ast.ForeachStatement:
		return c.compileForeach(n)
	case *ast.SwitchStatement:
		return c.compileSwitch(n)
	case *ast.BreakStatement:
		return c.compileBreak(n)
	case *ast.ContinueStatement:
		return c.compileContinue(n)
	case *ast.TryStatement:
		return c.compileTry(n)
	case *ast.ThrowStatement:
		return c.compileThrow(n)
	case *ast.BlockStatement:
		return c.compileBlock(n)
		
	// Declarations
	case *ast.FunctionDeclaration:
		return c.compileFunctionDeclaration(n)
	case *ast.ClassDeclaration:
		return c.compileClassDeclaration(n)
	case *ast.PropertyDeclaration:
		return c.compilePropertyDeclaration(n)
	case *ast.ClassConstantDeclaration:
		return c.compileClassConstant(n)
		
	// Program node
	case *ast.Program:
		return c.compileProgram(n)
		
	default:
		return fmt.Errorf("unsupported AST node type: %T", n)
	}
}

// Expression compilation methods

func (c *Compiler) compileBinaryOp(expr *ast.BinaryOpExpression) error {
	// Compile operands
	err := c.compileNode(expr.Left)
	if err != nil {
		return err
	}
	leftResult := c.allocateTemp()
	c.emitMove(leftResult)
	
	err = c.compileNode(expr.Right)
	if err != nil {
		return err
	}
	rightResult := c.allocateTemp()
	c.emitMove(rightResult)
	
	// Generate operation
	result := c.allocateTemp()
	opcode := c.getOpcodeForBinaryOperator(expr.Operator)
	c.emit(opcode, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, leftResult, opcodes.IS_TMP_VAR, rightResult)
	
	return nil
}

func (c *Compiler) compileUnaryOp(expr *ast.UnaryOpExpression) error {
	err := c.compileNode(expr.Operand)
	if err != nil {
		return err
	}
	
	operandResult := c.allocateTemp()
	c.emitMove(operandResult)
	
	result := c.allocateTemp()
	opcode := c.getOpcodeForUnaryOperator(expr.Operator)
	c.emit(opcode, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, operandResult, 0, 0)
	
	return nil
}

func (c *Compiler) compileAssign(expr *ast.AssignExpression) error {
	// Compile right-hand side first
	err := c.compileNode(expr.Value)
	if err != nil {
		return err
	}
	
	valueResult := c.allocateTemp()
	c.emitMove(valueResult)
	
	// Handle different left-hand side types
	switch target := expr.Variable.(type) {
	case *ast.VariableExpression:
		varSlot := c.getOrCreateVariable(target.Name)
		c.emit(opcodes.OP_ASSIGN, opcodes.IS_VAR, varSlot, opcodes.IS_TMP_VAR, valueResult, 0, 0)
		
	case *ast.ArrayAccessExpression:
		// Compile array expression
		err := c.compileNode(target.Array)
		if err != nil {
			return err
		}
		arrayResult := c.allocateTemp()
		c.emitMove(arrayResult)
		
		// Compile index expression
		err = c.compileNode(target.Index)
		if err != nil {
			return err
		}
		indexResult := c.allocateTemp()
		c.emitMove(indexResult)
		
		c.emit(opcodes.OP_FETCH_DIM_W, opcodes.IS_TMP_VAR, arrayResult, opcodes.IS_TMP_VAR, indexResult, opcodes.IS_TMP_VAR, valueResult)
		
	case *ast.PropertyAccessExpression:
		// Compile object expression
		err := c.compileNode(target.Object)
		if err != nil {
			return err
		}
		objectResult := c.allocateTemp()
		c.emitMove(objectResult)
		
		// Property name as constant
		propConstant := c.addConstant(values.NewString(target.Property))
		c.emit(opcodes.OP_FETCH_OBJ_W, opcodes.IS_TMP_VAR, objectResult, opcodes.IS_CONST, propConstant, opcodes.IS_TMP_VAR, valueResult)
		
	default:
		return fmt.Errorf("unsupported assignment target: %T", target)
	}
	
	return nil
}

func (c *Compiler) compileVariable(expr *ast.VariableExpression) error {
	varSlot := c.getOrCreateVariable(expr.Name)
	result := c.allocateTemp()
	c.emit(opcodes.OP_FETCH_R, opcodes.IS_TMP_VAR, result, opcodes.IS_VAR, varSlot, 0, 0)
	return nil
}

func (c *Compiler) compileIntegerLiteral(expr *ast.IntegerLiteral) error {
	value, err := strconv.ParseInt(expr.Value, 10, 64)
	if err != nil {
		return fmt.Errorf("invalid integer literal: %s", expr.Value)
	}
	
	constant := c.addConstant(values.NewInt(value))
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_CONST, constant, 0, 0)
	return nil
}

func (c *Compiler) compileFloatLiteral(expr *ast.FloatLiteral) error {
	value, err := strconv.ParseFloat(expr.Value, 64)
	if err != nil {
		return fmt.Errorf("invalid float literal: %s", expr.Value)
	}
	
	constant := c.addConstant(values.NewFloat(value))
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_CONST, constant, 0, 0)
	return nil
}

func (c *Compiler) compileStringLiteral(expr *ast.StringLiteral) error {
	constant := c.addConstant(values.NewString(expr.Value))
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_CONST, constant, 0, 0)
	return nil
}

func (c *Compiler) compileBooleanLiteral(expr *ast.BooleanLiteral) error {
	constant := c.addConstant(values.NewBool(expr.Value))
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_CONST, constant, 0, 0)
	return nil
}

func (c *Compiler) compileNullLiteral(expr *ast.NullLiteral) error {
	constant := c.addConstant(values.NewNull())
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_CONST, constant, 0, 0)
	return nil
}

func (c *Compiler) compileArray(expr *ast.ArrayExpression) error {
	result := c.allocateTemp()
	c.emit(opcodes.OP_INIT_ARRAY, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	
	for _, element := range expr.Elements {
		if element.Key != nil {
			// Keyed element
			err := c.compileNode(element.Key)
			if err != nil {
				return err
			}
			keyResult := c.allocateTemp()
			c.emitMove(keyResult)
			
			err = c.compileNode(element.Value)
			if err != nil {
				return err
			}
			valueResult := c.allocateTemp()
			c.emitMove(valueResult)
			
			c.emit(opcodes.OP_ADD_ARRAY_ELEMENT, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, keyResult, opcodes.IS_TMP_VAR, valueResult)
		} else {
			// Auto-indexed element
			err := c.compileNode(element.Value)
			if err != nil {
				return err
			}
			valueResult := c.allocateTemp()
			c.emitMove(valueResult)
			
			c.emit(opcodes.OP_ADD_ARRAY_ELEMENT, opcodes.IS_TMP_VAR, result, opcodes.IS_UNUSED, 0, opcodes.IS_TMP_VAR, valueResult)
		}
	}
	
	return nil
}

func (c *Compiler) compileArrayAccess(expr *ast.ArrayAccessExpression) error {
	// Compile array expression
	err := c.compileNode(expr.Array)
	if err != nil {
		return err
	}
	arrayResult := c.allocateTemp()
	c.emitMove(arrayResult)
	
	// Compile index expression
	err = c.compileNode(expr.Index)
	if err != nil {
		return err
	}
	indexResult := c.allocateTemp()
	c.emitMove(indexResult)
	
	result := c.allocateTemp()
	c.emit(opcodes.OP_FETCH_DIM_R, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, arrayResult, opcodes.IS_TMP_VAR, indexResult)
	
	return nil
}

func (c *Compiler) compilePropertyAccess(expr *ast.PropertyAccessExpression) error {
	// Compile object expression
	err := c.compileNode(expr.Object)
	if err != nil {
		return err
	}
	objectResult := c.allocateTemp()
	c.emitMove(objectResult)
	
	// Property name as constant
	propConstant := c.addConstant(values.NewString(expr.Property))
	result := c.allocateTemp()
	c.emit(opcodes.OP_FETCH_OBJ_R, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, objectResult, opcodes.IS_CONST, propConstant)
	
	return nil
}

func (c *Compiler) compileFunctionCall(expr *ast.FunctionCall) error {
	// Initialize function call
	funcNameConstant := c.addConstant(values.NewString(expr.Name))
	numArgs := uint32(len(expr.Arguments))
	
	c.emit(opcodes.OP_INIT_FCALL, opcodes.IS_CONST, funcNameConstant, opcodes.IS_CONST, c.addConstant(values.NewInt(int64(numArgs))), 0, 0)
	
	// Compile and send arguments
	for i, arg := range expr.Arguments {
		err := c.compileNode(arg)
		if err != nil {
			return err
		}
		argResult := c.allocateTemp()
		c.emitMove(argResult)
		
		argNum := c.addConstant(values.NewInt(int64(i)))
		c.emit(opcodes.OP_SEND_VAL, opcodes.IS_CONST, argNum, opcodes.IS_TMP_VAR, argResult, 0, 0)
	}
	
	// Execute call
	result := c.allocateTemp()
	c.emit(opcodes.OP_DO_FCALL, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	
	return nil
}

func (c *Compiler) compileMethodCall(expr *ast.MethodCall) error {
	// Compile object
	err := c.compileNode(expr.Object)
	if err != nil {
		return err
	}
	objectResult := c.allocateTemp()
	c.emitMove(objectResult)
	
	// Initialize method call
	methodNameConstant := c.addConstant(values.NewString(expr.Method))
	numArgs := uint32(len(expr.Arguments))
	
	c.emit(opcodes.OP_INIT_METHOD_CALL, opcodes.IS_TMP_VAR, objectResult, opcodes.IS_CONST, methodNameConstant, opcodes.IS_CONST, c.addConstant(values.NewInt(int64(numArgs))))
	
	// Compile and send arguments
	for i, arg := range expr.Arguments {
		err := c.compileNode(arg)
		if err != nil {
			return err
		}
		argResult := c.allocateTemp()
		c.emitMove(argResult)
		
		argNum := c.addConstant(values.NewInt(int64(i)))
		c.emit(opcodes.OP_SEND_VAL, opcodes.IS_CONST, argNum, opcodes.IS_TMP_VAR, argResult, 0, 0)
	}
	
	// Execute call
	result := c.allocateTemp()
	c.emit(opcodes.OP_DO_FCALL, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	
	return nil
}

func (c *Compiler) compileTernary(expr *ast.TernaryExpression) error {
	// Compile condition
	err := c.compileNode(expr.Condition)
	if err != nil {
		return err
	}
	condResult := c.allocateTemp()
	c.emitMove(condResult)
	
	// Jump labels
	elseLabel := c.generateLabel()
	endLabel := c.generateLabel()
	
	// Jump to else if condition is false
	c.emit(opcodes.OP_JMPZ, opcodes.IS_TMP_VAR, condResult, opcodes.IS_CONST, c.addLabel(elseLabel), 0, 0)
	
	// Compile true branch
	err = c.compileNode(expr.TrueExpr)
	if err != nil {
		return err
	}
	trueResult := c.allocateTemp()
	c.emitMove(trueResult)
	
	// Jump to end
	c.emit(opcodes.OP_JMP, opcodes.IS_CONST, c.addLabel(endLabel), 0, 0, 0, 0)
	
	// Else branch
	c.placeLabel(elseLabel)
	err = c.compileNode(expr.FalseExpr)
	if err != nil {
		return err
	}
	falseResult := c.allocateTemp()
	c.emitMove(falseResult)
	
	// End label
	c.placeLabel(endLabel)
	
	// Result assignment (this is simplified - real implementation would be more complex)
	result := c.allocateTemp()
	c.emit(opcodes.OP_QM_ASSIGN, opcodes.IS_TMP_VAR, result, opcodes.IS_TMP_VAR, trueResult, 0, 0)
	
	return nil
}

// Statement compilation methods

func (c *Compiler) compileExpressionStatement(stmt *ast.ExpressionStatement) error {
	return c.compileNode(stmt.Expression)
}

func (c *Compiler) compileEcho(stmt *ast.EchoStatement) error {
	for _, expr := range stmt.Expressions {
		err := c.compileNode(expr)
		if err != nil {
			return err
		}
		result := c.allocateTemp()
		c.emitMove(result)
		c.emit(opcodes.OP_ECHO, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	}
	return nil
}

func (c *Compiler) compileReturn(stmt *ast.ReturnStatement) error {
	if stmt.Value != nil {
		err := c.compileNode(stmt.Value)
		if err != nil {
			return err
		}
		result := c.allocateTemp()
		c.emitMove(result)
		c.emit(opcodes.OP_RETURN, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	} else {
		nullConstant := c.addConstant(values.NewNull())
		c.emit(opcodes.OP_RETURN, opcodes.IS_CONST, nullConstant, 0, 0, 0, 0)
	}
	return nil
}

func (c *Compiler) compileIf(stmt *ast.IfStatement) error {
	// Compile condition
	err := c.compileNode(stmt.Condition)
	if err != nil {
		return err
	}
	condResult := c.allocateTemp()
	c.emitMove(condResult)
	
	// Generate labels
	elseLabel := c.generateLabel()
	endLabel := c.generateLabel()
	
	// Jump to else if condition is false
	c.emit(opcodes.OP_JMPZ, opcodes.IS_TMP_VAR, condResult, opcodes.IS_CONST, c.addLabel(elseLabel), 0, 0)
	
	// Compile consequence
	err = c.compileNode(stmt.Consequence)
	if err != nil {
		return err
	}
	
	// Jump to end
	c.emit(opcodes.OP_JMP, opcodes.IS_CONST, c.addLabel(endLabel), 0, 0, 0, 0)
	
	// Else branch
	c.placeLabel(elseLabel)
	if stmt.Alternative != nil {
		err = c.compileNode(stmt.Alternative)
		if err != nil {
			return err
		}
	}
	
	// End label
	c.placeLabel(endLabel)
	
	return nil
}

func (c *Compiler) compileWhile(stmt *ast.WhileStatement) error {
	// Labels
	startLabel := c.generateLabel()
	endLabel := c.generateLabel()
	
	// Set break/continue labels for this scope
	oldBreak := c.currentScope().breakLabel
	oldContinue := c.currentScope().continueLabel
	c.currentScope().breakLabel = endLabel
	c.currentScope().continueLabel = startLabel
	
	// Start of loop
	c.placeLabel(startLabel)
	
	// Compile condition
	err := c.compileNode(stmt.Condition)
	if err != nil {
		return err
	}
	condResult := c.allocateTemp()
	c.emitMove(condResult)
	
	// Jump to end if condition is false
	c.emit(opcodes.OP_JMPZ, opcodes.IS_TMP_VAR, condResult, opcodes.IS_CONST, c.addLabel(endLabel), 0, 0)
	
	// Compile body
	err = c.compileNode(stmt.Body)
	if err != nil {
		return err
	}
	
	// Jump back to start
	c.emit(opcodes.OP_JMP, opcodes.IS_CONST, c.addLabel(startLabel), 0, 0, 0, 0)
	
	// End label
	c.placeLabel(endLabel)
	
	// Restore labels
	c.currentScope().breakLabel = oldBreak
	c.currentScope().continueLabel = oldContinue
	
	return nil
}

func (c *Compiler) compileProgram(program *ast.Program) error {
	for _, stmt := range program.Statements {
		err := c.compileNode(stmt)
		if err != nil {
			return err
		}
	}
	return nil
}

// Helper methods

func (c *Compiler) emit(opcode opcodes.Opcode, op1Type opcodes.OpType, op1 uint32, op2Type opcodes.OpType, op2 uint32, resultType opcodes.OpType, result uint32) {
	opType1, opType2 := opcodes.EncodeOpTypes(op1Type, op2Type, resultType)
	
	instruction := opcodes.Instruction{
		Opcode:  opcode,
		OpType1: opType1,
		OpType2: opType2,
		Op1:     op1,
		Op2:     op2,
		Result:  result,
	}
	
	c.instructions = append(c.instructions, instruction)
}

func (c *Compiler) emitMove(target uint32) {
	// This is a placeholder for moving the top of stack to target
	// In a real implementation, this would be more sophisticated
}

func (c *Compiler) addConstant(value *values.Value) uint32 {
	c.constants = append(c.constants, value)
	return uint32(len(c.constants) - 1)
}

func (c *Compiler) allocateTemp() uint32 {
	temp := c.nextTemp
	c.nextTemp++
	return temp
}

func (c *Compiler) generateLabel() string {
	label := fmt.Sprintf("L%d", c.nextLabel)
	c.nextLabel++
	return label
}

func (c *Compiler) addLabel(name string) uint32 {
	// This would add a forward reference to be resolved later
	return uint32(len(c.instructions)) // Placeholder
}

func (c *Compiler) placeLabel(name string) {
	c.labels[name] = len(c.instructions)
}

func (c *Compiler) pushScope(isFunction bool) {
	scope := &Scope{
		variables:  make(map[string]uint32),
		parent:     c.currentScope(),
		nextSlot:   0,
		isFunction: isFunction,
	}
	c.scopes = append(c.scopes, scope)
}

func (c *Compiler) popScope() {
	if len(c.scopes) > 0 {
		c.scopes = c.scopes[:len(c.scopes)-1]
	}
}

func (c *Compiler) currentScope() *Scope {
	if len(c.scopes) == 0 {
		return nil
	}
	return c.scopes[len(c.scopes)-1]
}

func (c *Compiler) getOrCreateVariable(name string) uint32 {
	scope := c.currentScope()
	if scope == nil {
		// Create global scope
		c.pushScope(false)
		scope = c.currentScope()
	}
	
	if slot, exists := scope.variables[name]; exists {
		return slot
	}
	
	slot := scope.nextSlot
	scope.variables[name] = slot
	scope.nextSlot++
	return slot
}

// Operator mapping methods

func (c *Compiler) getOpcodeForBinaryOperator(operator string) opcodes.Opcode {
	switch operator {
	case "+":
		return opcodes.OP_ADD
	case "-":
		return opcodes.OP_SUB
	case "*":
		return opcodes.OP_MUL
	case "/":
		return opcodes.OP_DIV
	case "%":
		return opcodes.OP_MOD
	case "**":
		return opcodes.OP_POW
	case ".":
		return opcodes.OP_CONCAT
	case "==":
		return opcodes.OP_IS_EQUAL
	case "!=", "<>":
		return opcodes.OP_IS_NOT_EQUAL
	case "===":
		return opcodes.OP_IS_IDENTICAL
	case "!==":
		return opcodes.OP_IS_NOT_IDENTICAL
	case "<":
		return opcodes.OP_IS_SMALLER
	case "<=":
		return opcodes.OP_IS_SMALLER_OR_EQUAL
	case ">":
		return opcodes.OP_IS_GREATER
	case ">=":
		return opcodes.OP_IS_GREATER_OR_EQUAL
	case "<=>":
		return opcodes.OP_SPACESHIP
	case "&&":
		return opcodes.OP_BOOLEAN_AND
	case "||":
		return opcodes.OP_BOOLEAN_OR
	case "and":
		return opcodes.OP_LOGICAL_AND
	case "or":
		return opcodes.OP_LOGICAL_OR
	case "xor":
		return opcodes.OP_LOGICAL_XOR
	case "&":
		return opcodes.OP_BW_AND
	case "|":
		return opcodes.OP_BW_OR
	case "^":
		return opcodes.OP_BW_XOR
	case "<<":
		return opcodes.OP_SL
	case ">>":
		return opcodes.OP_SR
	default:
		return opcodes.OP_NOP
	}
}

func (c *Compiler) getOpcodeForUnaryOperator(operator string) opcodes.Opcode {
	switch operator {
	case "+":
		return opcodes.OP_PLUS
	case "-":
		return opcodes.OP_MINUS
	case "!":
		return opcodes.OP_NOT
	case "~":
		return opcodes.OP_BW_NOT
	case "++":
		return opcodes.OP_PRE_INC
	case "--":
		return opcodes.OP_PRE_DEC
	default:
		return opcodes.OP_NOP
	}
}

// Placeholder implementations for missing methods

func (c *Compiler) compileCoalesce(expr *ast.CoalesceExpression) error {
	// TODO: Implement null coalescing operator
	return fmt.Errorf("coalesce operator not implemented")
}

func (c *Compiler) compileMatch(expr *ast.MatchExpression) error {
	// TODO: Implement match expression
	return fmt.Errorf("match expression not implemented")
}

func (c *Compiler) compileFor(stmt *ast.ForStatement) error {
	// TODO: Implement for loop
	return fmt.Errorf("for loop not implemented")
}

func (c *Compiler) compileForeach(stmt *ast.ForeachStatement) error {
	// TODO: Implement foreach loop
	return fmt.Errorf("foreach loop not implemented")
}

func (c *Compiler) compileSwitch(stmt *ast.SwitchStatement) error {
	// TODO: Implement switch statement
	return fmt.Errorf("switch statement not implemented")
}

func (c *Compiler) compileBreak(stmt *ast.BreakStatement) error {
	scope := c.currentScope()
	if scope == nil || scope.breakLabel == "" {
		return fmt.Errorf("break statement not in loop")
	}
	c.emit(opcodes.OP_JMP, opcodes.IS_CONST, c.addLabel(scope.breakLabel), 0, 0, 0, 0)
	return nil
}

func (c *Compiler) compileContinue(stmt *ast.ContinueStatement) error {
	scope := c.currentScope()
	if scope == nil || scope.continueLabel == "" {
		return fmt.Errorf("continue statement not in loop")
	}
	c.emit(opcodes.OP_JMP, opcodes.IS_CONST, c.addLabel(scope.continueLabel), 0, 0, 0, 0)
	return nil
}

func (c *Compiler) compileTry(stmt *ast.TryStatement) error {
	// TODO: Implement try-catch statement
	return fmt.Errorf("try-catch statement not implemented")
}

func (c *Compiler) compileThrow(stmt *ast.ThrowStatement) error {
	err := c.compileNode(stmt.Exception)
	if err != nil {
		return err
	}
	result := c.allocateTemp()
	c.emitMove(result)
	c.emit(opcodes.OP_THROW, opcodes.IS_TMP_VAR, result, 0, 0, 0, 0)
	return nil
}

func (c *Compiler) compileBlock(stmt *ast.BlockStatement) error {
	for _, s := range stmt.Statements {
		err := c.compileNode(s)
		if err != nil {
			return err
		}
	}
	return nil
}

func (c *Compiler) compileFunctionDeclaration(decl *ast.FunctionDeclaration) error {
	// TODO: Implement function declaration
	return fmt.Errorf("function declaration not implemented")
}

func (c *Compiler) compileClassDeclaration(decl *ast.ClassDeclaration) error {
	// TODO: Implement class declaration
	return fmt.Errorf("class declaration not implemented")
}

func (c *Compiler) compilePropertyDeclaration(decl *ast.PropertyDeclaration) error {
	// TODO: Implement property declaration
	return fmt.Errorf("property declaration not implemented")
}

func (c *Compiler) compileClassConstant(decl *ast.ClassConstantDeclaration) error {
	// TODO: Implement class constant declaration
	return fmt.Errorf("class constant declaration not implemented")
}